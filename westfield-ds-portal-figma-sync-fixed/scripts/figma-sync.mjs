/**
 * Figma Sync (build-time)
 * - Pulls Variables + Styles + Component inventory from a Figma file
 * - Generates:
 *   - src/lib/figma/tokens.generated.ts
 *   - src/lib/figma/tokens.generated.css
 *   - src/lib/figma/components.generated.ts
 *
 * Works best when your Figma file uses Variables (Figma Variables) for colors/spacing/etc.
 *
 * Required env vars:
 *   FIGMA_API_TOKEN
 *   FIGMA_FILE_KEY
 *
 * Optional:
 *   FIGMA_COMPONENTS_PAGE_NODE_ID  (e.g. "4:6598") to scope component extraction
 *
 * Notes:
 * - This script is intended to run at build-time (Vercel build) or locally.
 * - Do NOT run tokened Figma calls from the browser.
 */

import fs from "node:fs";
import path from "node:path";

const FIGMA_API = "https://api.figma.com/v1";

const token = process.env.FIGMA_API_TOKEN;
const fileKey = process.env.FIGMA_FILE_KEY;

const outDir = path.join(process.cwd(), "src", "lib", "figma");
fs.mkdirSync(outDir, { recursive: true });

function writeFile(rel, content) {
  const p = path.join(process.cwd(), rel);
  fs.mkdirSync(path.dirname(p), { recursive: true });
  fs.writeFileSync(p, content, "utf8");
}

async function figma(pathname) {
  const res = await fetch(`${FIGMA_API}${pathname}`, {
    headers: { "X-Figma-Token": token },
  });
  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`Figma API ${res.status} for ${pathname}\n${txt}`);
  }
  return res.json();
}

function rgbaToHex({ r, g, b, a }) {
  // Figma uses 0..1
  const to255 = (x) => Math.round(Math.max(0, Math.min(1, x)) * 255);
  const R = to255(r).toString(16).padStart(2, "0");
  const G = to255(g).toString(16).padStart(2, "0");
  const B = to255(b).toString(16).padStart(2, "0");
  if (a === undefined || a === 1) return `#${R}${G}${B}`;
  const A = to255(a).toString(16).padStart(2, "0");
  return `#${R}${G}${B}${A}`;
}

function slugify(s) {
  return String(s)
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)/g, "");
}

/**
 * Extract components from the file document.
 * We grab COMPONENT / COMPONENT_SET nodes and map:
 * - name
 * - nodeId
 * - inferred type (component-set vs component)
 */
function collectComponents(node, results) {
  if (!node || typeof node !== "object") return;
  if (node.type === "COMPONENT" || node.type === "COMPONENT_SET") {
    results.push({
      name: node.name || "Unnamed",
      nodeId: node.id,
      kind: node.type === "COMPONENT_SET" ? "set" : "component",
      description: null,
    });
  }
  const kids = node.children || [];
  for (const k of kids) collectComponents(k, results);
}

/**
 * Variables: convert to a minimal token map.
 * Figma variables payloads differ by file setup, so we implement a tolerant normalizer.
 */
function normalizeVariables(payload) {
  // Expected-ish shape: { meta: { variables: {id: {...}}, variableCollections: {id: {...}} } }
  const meta = payload?.meta;
  const variables = meta?.variables || {};
  const collections = meta?.variableCollections || {};

  // Choose a "default mode" per collection (first mode)
  const defaultModeByCollection = {};
  for (const [cid, col] of Object.entries(collections)) {
    const modes = col?.modes || [];
    defaultModeByCollection[cid] = modes[0]?.modeId || null;
  }

  const out = {
    colors: {},
    numbers: {},
    strings: {},
    raw: {},
  };

  for (const [vid, v] of Object.entries(variables)) {
    const name = v.name || vid;
    const collectionId = v.variableCollectionId;
    const modeId = defaultModeByCollection[collectionId] || Object.keys(v.valuesByMode || {})[0];
    const value = v.valuesByMode?.[modeId];

    out.raw[name] = { id: vid, resolvedMode: modeId, valueType: v.resolvedType, value };

    if (value == null) continue;

    // Color (RGBA object)
    if (typeof value === "object" && value.r !== undefined && value.g !== undefined && value.b !== undefined) {
      out.colors[name] = rgbaToHex(value);
      continue;
    }

    // Number
    if (typeof value === "number") {
      out.numbers[name] = value;
      continue;
    }

    // String
    if (typeof value === "string") {
      out.strings[name] = value;
      continue;
    }
  }

  return out;
}

function generateCssVars(tokens) {
  // Map token keys → CSS variables.
  // Convention: --ds-{slug}
  const lines = [];
  lines.push(":root {");

  for (const [k, hex] of Object.entries(tokens.colors)) {
    lines.push(`  --ds-${slugify(k)}: ${hex};`);
  }
  for (const [k, n] of Object.entries(tokens.numbers)) {
    // assume px for sizes unless the token name suggests otherwise
    const unit = /opacity|z-?index|weight/i.test(k) ? "" : "px";
    lines.push(`  --ds-${slugify(k)}: ${n}${unit};`);
  }
  for (const [k, s] of Object.entries(tokens.strings)) {
    lines.push(`  --ds-${slugify(k)}: ${JSON.stringify(s)};`);
  }

  lines.push("}");
  lines.push("");
  return lines.join("\n");
}

function generateTokensTs(tokens) {
  return `// AUTO-GENERATED by scripts/figma-sync.mjs — do not edit by hand.
export const figmaTokens = ${JSON.stringify(tokens, null, 2)} as const;

export type FigmaTokens = typeof figmaTokens;
`;
}

function generateComponentsTs(items) {
  // Build portal-friendly meta list (minimal).
  const metas = items
    .sort((a, b) => a.name.localeCompare(b.name))
    .map((c) => ({
      name: c.name,
      slug: slugify(c.name),
      nodeId: c.nodeId,
      kind: c.kind,
    }));

  return `// AUTO-GENERATED by scripts/figma-sync.mjs — do not edit by hand.
export type FigmaComponent = {
  name: string;
  slug: string;
  nodeId: string;
  kind: "set" | "component";
};

export const figmaComponents: FigmaComponent[] = ${JSON.stringify(metas, null, 2)};
`;
}

async function main() {
  // If no token, keep the repo buildable by writing stub generated files.
  if (!token || !fileKey) {
    console.warn("[figma-sync] FIGMA_API_TOKEN / FIGMA_FILE_KEY not set. Writing stub generated files.");
    writeFile("src/lib/figma/tokens.generated.ts", generateTokensTs({ colors: {}, numbers: {}, strings: {}, raw: {} }));
    writeFile("src/lib/figma/tokens.generated.css", ":root {}\n");
    writeFile("src/lib/figma/components.generated.ts", generateComponentsTs([]));
    return;
  }

  console.log("[figma-sync] Fetching variables…");
  const variables = await figma(`/files/${fileKey}/variables/local`);
  const tokens = normalizeVariables(variables);

  console.log("[figma-sync] Fetching file document for components…");
  const file = await figma(`/files/${fileKey}`);
  const items = [];
  collectComponents(file?.document, items);

  console.log(`[figma-sync] Found ${items.length} components/component-sets`);

  writeFile("src/lib/figma/tokens.generated.ts", generateTokensTs(tokens));
  writeFile("src/lib/figma/tokens.generated.css", generateCssVars(tokens));
  writeFile("src/lib/figma/components.generated.ts", generateComponentsTs(items));
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
